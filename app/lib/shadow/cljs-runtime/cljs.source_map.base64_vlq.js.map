{"version":3,"sources":["cljs/source_map/base64_vlq.cljs"],"mappings":";;AAaA,4CAAA,5CAAaA;AACb,AAAaC,sCAAS,CAAA,OAAkBD,AAAA;AACxC,AAAaE,2CAAc,uCAAA,tCAAKD;AAChC,AAAaE,kDAAqBF;AAElC,2CAAA,3CAAMG,8FAAeC;AAArB,AACE,GAAI,KAAA,JAAMA;AACR,yBAAA,jBAAK,UAAA,TAAgB,GAAGA;;AACxB,qBAAA,bAAG,MAAA,LAAgBA;;;AAEvB,6CAAA,7CAAMC,kGAAiBD;AAAvB,AACE,IAAME,aAAK,uDAAA,vDAACC,6CAAE,KAAA,JAASH;IACjBI,UAAQ,MAAA,LAAiBJ;AAD/B,AAEE,GAAIE;AACF,UAAGE;;AACHA;;;AAEN,wCAAA,xCAAMC,wFAAYC;AAAlB,AACE,IAAMC,KAAG,KAAAC;IACHC,MAAI,AAACV,yCAAcO;AADzB,AAEE,IAAOI,aAAM,CAASD,MAAIZ;IACnBY,eAAM,CAA2BA,QAAId,AAAA;;AAD5C,AAEE,GAAI,gBAAA,fAAMc;AACR,IAAMC,iBAAM,CAAQA,aAAMZ;AAA1B,AACE,AAASS,UAAG,AAACI,8BAAcD;;AAC3B,cAAO,CAASD,eAAIZ;cACb,CAA2BY,iBAAId,AAAA;;;;;AACxC,AAASY,UAAG,AAACI,8BAAcD;;;;;AAC/B,mDAAKH;;AAET,oCAAA,pCAAMK,gFAAQZ;AAAd,AACE,OAACa,8CAAMC,cAAI,AAACC,4CAAIV,sCAAWL;;AAE7B,oCAAA,pCAAMgB,gFAAQC;AAAd,AACE,IAAMC,IAAE,AAAUD;AAAlB,AACE,QAAA,JAAOE;aAAP,TAAWC;YAAX,RAAoBC;;AAApB,AACE,GAAM,CAAIF,KAAED;AAAZ,AACE,MAAO,KAAAI,MAAA;;AADT;;AAEA,IAAMZ,QAAM,AAACa,8BAAc,AAASN,SAAEE;AAAtC,AACE,IAAMA,QAAE,KAAA,JAAKA;IACPK,sBAAc,6DAAA,5DAAM,CAASd,QAAMZ;IACnCY,YAAM,CAASA,QAAMb;IACrBuB,aAAO,CAAGA,SAAO,CAAgBV,aAAMW;IACvCA,YAAM,CAAGA,QAAM1B,AAAA;AAJrB,AAKE,GAAI6B;AACF,cAAOL;cAAEC;cAAOC;;;;;;AAChB,YAAAI,kBAAA,KAAA;;AAAA,AACC,OAACC,eAAK,AAACzB,2CAAgBmB,YACjB,iBAAMH,QAAE,AAAYA,YAAEE;AAAtB,AACE,GAAU,AAACQ,4BAAcV;AAAzB;;AAAA,AACE,QAACD,kEAAAA,yEAAAA,TAAOC,qDAAAA;;;;CAJnB,KAAA;;;;;AAMZ","names":["cljs.source-map.base64-vlq/vlq-base-shift","cljs.source-map.base64-vlq/vlq-base","cljs.source-map.base64-vlq/vlq-base-mask","cljs.source-map.base64-vlq/vlq-continuation-bit","cljs.source-map.base64-vlq/to-vlq-signed","v","cljs.source-map.base64-vlq/from-vlq-signed","neg?","cljs.core._EQ_","shifted","cljs.source-map.base64-vlq/encode-val","n","sb","js/goog.string.StringBuffer","vlq","digit","cljs.source-map.base64/encode","cljs.source-map.base64-vlq/encode","cljs.core.apply","cljs.core/str","cljs.core.map","cljs.source-map.base64-vlq/decode","s","l","i","result","shift","js/Error","cljs.source-map.base64/decode","continuation?","cljs.core/LazySeq","cljs.core/cons","clojure.string/blank?"],"sourcesContent":[";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.source-map.base64-vlq\n  (:require [clojure.string :as string]\n            [cljs.source-map.base64 :as base64])\n  (:import [goog.string StringBuffer]))\n\n(def ^:const vlq-base-shift 5)\n(def ^:const vlq-base (bit-shift-left 1 vlq-base-shift))\n(def ^:const vlq-base-mask (dec vlq-base))\n(def ^:const vlq-continuation-bit vlq-base)\n\n(defn to-vlq-signed [v]\n  (if (neg? v)\n    (inc (bit-shift-left (- v) 1))\n    (+ (bit-shift-left v 1) 0)))\n\n(defn from-vlq-signed [v]\n  (let [neg? (= (bit-and v 1) 1)\n        shifted (bit-shift-right v 1)]\n    (if neg?\n      (- shifted)\n      shifted)))\n\n(defn encode-val [n]\n  (let [sb (StringBuffer.)\n        vlq (to-vlq-signed n)]\n    (loop [digit (bit-and vlq vlq-base-mask)\n           vlq   (bit-shift-right-zero-fill vlq vlq-base-shift)]\n      (if (pos? vlq)\n        (let [digit (bit-or digit vlq-continuation-bit)]\n          (.append sb (base64/encode digit))\n          (recur (bit-and vlq vlq-base-mask)\n                 (bit-shift-right-zero-fill vlq vlq-base-shift)))\n        (.append sb (base64/encode digit))))\n    (str sb)))\n\n(defn encode [v]\n  (apply str (map encode-val v)))\n\n(defn decode [s]\n  (let [l (.-length s)]\n    (loop [i 0 result 0 shift 0]\n      (when (>= i l)\n        (throw (js/Error. \"Expected more digits in base 64 VLQ value.\")))\n      (let [digit (base64/decode (.charAt s i))]\n        (let [i (inc i)\n              continuation? (pos? (bit-and digit vlq-continuation-bit))\n              digit (bit-and digit vlq-base-mask)\n              result (+ result (bit-shift-left digit shift))\n              shift (+ shift vlq-base-shift)]\n          (if continuation?\n            (recur i result shift)\n            (lazy-seq\n             (cons (from-vlq-signed result)\n                   (let [s (.substring s i)]\n                     (when-not (string/blank? s)\n                       (decode s)))))))))))\n\n(comment\n  ;; tests\n\n  (bit-shift-right-zero-fill 127 1) ;; 63\n  (bit-shift-right-zero-fill -127 1) ;; 2147483584\n  \n  (to-vlq-signed 32) ;; 64\n  (to-vlq-signed -32) ;; 65\n  (from-vlq-signed 64) ;; 32\n  (from-vlq-signed 65) ;; -32\n\n  ;; Base64 VLQ can only represent 32bit values\n\n  (encode-val 32) ; \"gC\"\n  (decode \"gC\") ; {:value 32 :rest \"\"}\n\n  (decode \"AAgBC\") ; (0 0 16 1)\n  \n  ;; lines kept count by semicolons, segments delimited by commas\n  ;; the above is gline 0, gcol 0, file 0, line 16, col 1, no name if this was the first segment read\n\n  (decode \"AAggBC\") ; very clever way to encode large values\n  (decode \"AAggBCA\") ; 5 values instead of 4\n\n  (encode [0 0 16 1]) ; \"AAgBC\"\n\n  (decode \"IAWdD\") ; (4 0 11 -14 -1) this is correct\n  ;; gline N, gcol +4, file +0, line +11, col -14, name -1\n\n  ;; Notes about format\n  ;; we always have 1, 4, or 5 values, all zero-based indexes\n  ;; 1. generated col - relative - reset on every new line in generated source\n  ;; 2. index into sources list - relative\n  ;; 3. original line - relative\n  ;; 4. origin column - relative\n  ;; 5. name - relative\n  )\n"],"x_google_ignoreList":[0]}